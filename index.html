<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Negative Space - Hardcore Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: #000; cursor: pointer; z-index: 10;
            padding: 20px; border: 2px solid #000; transition: 0.3s;
        }
        #overlay:hover { background: #000; color: #fff; }
    </style>
</head>
<body>

<div id="overlay">CLICK TO UNLEASH THE NOISE</div>
<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, particleSystem, analyser, dataArray;
    let particleCount = 15000;
    let positions, initialPositions;

    const overlay = document.getElementById('overlay');
    overlay.addEventListener('click', initAudio);

    function init() {
        // 1. 場景與渲染器 (純白底)
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 2. 建立粒子 (純黑)
        const geometry = new THREE.BufferGeometry();
        positions = new Float32Array(particleCount * 3);
        initialPositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            let i3 = i * 3;
            // 初始分佈：稍微不規則的球體
            const r = 1.2;
            const theta = Math.acos(2 * Math.random() - 1);
            const phi = 2 * Math.PI * Math.random();

            positions[i3] = r * Math.sin(theta) * Math.cos(phi);
            positions[i3 + 1] = r * Math.sin(theta) * Math.sin(phi);
            positions[i3 + 2] = r * Math.cos(theta);

            initialPositions[i3] = positions[i3];
            initialPositions[i3 + 1] = positions[i3 + 1];
            initialPositions[i3 + 2] = positions[i3 + 2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0x000000,
            size: 0.015,
            transparent: true,
            opacity: 0.6,
            blending: THREE.NormalBlending // 白底下正常的混合模式
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        window.addEventListener('resize', onWindowResize, false);
        animate();
    }

    async function initAudio() {
		overlay.style.display = 'none';

		// 1. 強制設定 SampleRate 解決音速偏差問題 (常見於行動裝置)
		const audioContext = new (window.AudioContext || window.webkitAudioContext)({
			sampleRate: 44100 
		});

		const audio = new Audio();
		audio.src = '沒醉.mp3';
		audio.crossOrigin = "anonymous";
		audio.loop = true; // 開啟單曲循環

		const transparentPixel = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";

		// 2. Media Session (鎖屏控制面板) 設定
		if ('mediaSession' in navigator) {
			navigator.mediaSession.metadata = new MediaMetadata({
				title: '沒醉',
				album: 'feel',
				artwork: [
					{ src: transparentPixel, sizes: '1x1', type: 'image/png' }
				]
			});

			// 定義狀態同步邏輯
			const syncState = (state) => {
				navigator.mediaSession.playbackState = state;
			};

			// 監聽播放事件 (不論是網頁按或是鎖屏按都能同步)
			audio.addEventListener('play', () => syncState("playing"));
			audio.addEventListener('pause', () => syncState("paused"));

			// 控制面板：播放與暫停
			navigator.mediaSession.setActionHandler('play', async () => {
				if (audioContext.state === 'suspended') await audioContext.resume();
				audio.play();
			});

			navigator.mediaSession.setActionHandler('pause', () => {
				audio.pause();
			});

			// 控制面板：如果你想顯示「上一首/下一首」按鈕，解開註解並放入邏輯
			/*
			navigator.mediaSession.setActionHandler('previoustrack', () => { 
				 // 這裡放入切換歌曲的邏輯
			});
			navigator.mediaSession.setActionHandler('nexttrack', () => { 
				 // 這裡放入切換歌曲的邏輯
			});
			*/
		}

		// 3. Web Audio API 節點連接
		const source = audioContext.createMediaElementSource(audio);
		analyser = audioContext.createAnalyser();
		analyser.fftSize = 256;
		
		source.connect(audioContext.destination);
		source.connect(analyser);
		//analyser.connect(audioContext.destination);

		dataArray = new Uint8Array(analyser.frequencyBinCount);

		// 4. 處理「切換分頁/切回網頁」的音訊重啟機制
		document.addEventListener('visibilitychange', () => {
			if (document.visibilityState === 'visible') {
				if (audioContext.state === 'suspended') {
					audioContext.resume();
				}
			}
		});
		
		// 確保 AudioContext 啟動並播放
		if (audioContext.state === 'suspended') {
			await audioContext.resume();
		}
		
		audio.play();
	}

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (analyser) {
            analyser.getByteFrequencyData(dataArray);
            
            // 抓取低頻強度作為整體縮放
            const averageFreq = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const boost = averageFreq / 255;

            const posAttribute = particleSystem.geometry.attributes.position;
            const time = Date.now() * 0.002;

            for (let i = 0; i < particleCount; i++) {
                let i3 = i * 3;
                let freqVal = dataArray[i % dataArray.length] / 255.0;

                // 數學混亂邏輯：結合 Sine 波與頻率造成的空間扭曲
                // 當頻率高時，粒子會沿著法線方向劇烈噴射
                let noise = Math.sin(initialPositions[i3] * 2 + time) * 0.1;
                let scale = 1.0 + (freqVal * 1.5) + (boost * 0.5);

                posAttribute.array[i3] = initialPositions[i3] * scale + noise;
                posAttribute.array[i3+1] = initialPositions[i3+1] * scale + noise;
                posAttribute.array[i3+2] = initialPositions[i3+2] * scale + noise;
            }
            
            posAttribute.needsUpdate = true;
            
            // 讓球體緩慢旋轉
            particleSystem.rotation.y += 0.005;
            particleSystem.rotation.x += 0.002;

            // 如果音樂超響，背景稍微閃爍灰色，模擬過曝感
            if (boost > 0.6) {
                scene.background = new THREE.Color(0xdddddd);
            } else {
                scene.background = new THREE.Color(0xffffff);
            }
        }

        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>
