<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Negative Space - Hardcore Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: #000; cursor: pointer; z-index: 10;
            padding: 20px; border: 2px solid #000; transition: 0.3s;
        }
        #overlay:hover { background: #000; color: #fff; }
    </style>
</head>
<body>

<div id="overlay">CLICK TO UNLEASH THE NOISE</div>
<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, particleSystem, analyser, dataArray;
    let particleCount = 15000;
    let positions, initialPositions;

    const overlay = document.getElementById('overlay');
    overlay.addEventListener('click', initAudio);

    function init() {
        // 1. 場景與渲染器 (純白底)
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 2. 建立粒子 (純黑)
        const geometry = new THREE.BufferGeometry();
        positions = new Float32Array(particleCount * 3);
        initialPositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            let i3 = i * 3;
            // 初始分佈：稍微不規則的球體
            const r = 1.2;
            const theta = Math.acos(2 * Math.random() - 1);
            const phi = 2 * Math.PI * Math.random();

            positions[i3] = r * Math.sin(theta) * Math.cos(phi);
            positions[i3 + 1] = r * Math.sin(theta) * Math.sin(phi);
            positions[i3 + 2] = r * Math.cos(theta);

            initialPositions[i3] = positions[i3];
            initialPositions[i3 + 1] = positions[i3 + 1];
            initialPositions[i3 + 2] = positions[i3 + 2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0x000000,
            size: 0.015,
            transparent: true,
            opacity: 0.6,
            blending: THREE.NormalBlending // 白底下正常的混合模式
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        window.addEventListener('resize', onWindowResize, false);
        animate();
    }

    async function initAudio() {
        overlay.style.display = 'none';

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audio = new Audio();
        audio.src = 'music.mp3'; // 確保檔案名稱完全正確
        audio.crossOrigin = "anonymous";
        
        const source = audioContext.createMediaElementSource(audio);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256; // 較小的 FFT 讓視覺更硬核、跳動更尖銳
        
        source.connect(analyser);
        analyser.connect(audioContext.destination);

        dataArray = new Uint8Array(analyser.frequencyBinCount);
        audio.play();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (analyser) {
            analyser.getByteFrequencyData(dataArray);
            
            // 抓取低頻強度作為整體縮放
            const averageFreq = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const boost = averageFreq / 255;

            const posAttribute = particleSystem.geometry.attributes.position;
            const time = Date.now() * 0.002;

            for (let i = 0; i < particleCount; i++) {
                let i3 = i * 3;
                let freqVal = dataArray[i % dataArray.length] / 255.0;

                // 數學混亂邏輯：結合 Sine 波與頻率造成的空間扭曲
                // 當頻率高時，粒子會沿著法線方向劇烈噴射
                let noise = Math.sin(initialPositions[i3] * 2 + time) * 0.1;
                let scale = 1.0 + (freqVal * 1.5) + (boost * 0.5);

                posAttribute.array[i3] = initialPositions[i3] * scale + noise;
                posAttribute.array[i3+1] = initialPositions[i3+1] * scale + noise;
                posAttribute.array[i3+2] = initialPositions[i3+2] * scale + noise;
            }
            
            posAttribute.needsUpdate = true;
            
            // 讓球體緩慢旋轉
            particleSystem.rotation.y += 0.005;
            particleSystem.rotation.x += 0.002;

            // 如果音樂超響，背景稍微閃爍灰色，模擬過曝感
            if (boost > 0.6) {
                scene.background = new THREE.Color(0xdddddd);
            } else {
                scene.background = new THREE.Color(0xffffff);
            }
        }

        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>
