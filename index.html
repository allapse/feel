<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Negative Space - Dark Glow Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: 'Courier New', Courier, monospace; cursor: crosshair; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* 極簡 Slider 樣式 */
        #ui-layer {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 20; color: #999; display: none;
        }
        .control-group { margin-bottom: 20px; }
        label { font-size: 9px; display: block; margin-bottom: 8px; text-transform: uppercase;}
        
        input[type=range] {
            -webkit-appearance: none; width: 180px; background: transparent;
        }
        input[type=range]:focus { outline: none; }
        /* 軌道 */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 1px; background: #999; border: none;
        }
        /* 拉桿 */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 12px; 
            background: #999; cursor: pointer; margin-top: -5.5px;
            border-radius: 0; border: 1px solid #fff;
        }

        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: #999; cursor: pointer; z-index: 100;
            padding: 30px; border: 0px solid #000; transition: 0.4s; letter-spacing: 4px; font-size: 12px;
			background: rgba(0, 0, 0, 0.6);
        }
        #overlay:hover { background: rgba(0, 0, 0, 0.7); color: #fff; }

        #mode-hint {
            position: absolute; bottom: 20px; right: 20px; font-size: 9px; color: #999;
            letter-spacing: 1px; pointer-events: none; display: none;
        }
		
		#canvas-container { 
			width: 100vw; 
			height: 100vh; 
			touch-action: none; /* 重要：防止瀏覽器攔截觸控事件 */
		}
    </style>
</head>
<body>

<div id="overlay">INITIATE_SYSTEM</div>
<div id="mode-hint">TAP TO GLOW</div>

<div id="ui-layer">
    <div class="control-group">
        <label>Distortion</label>
        <input type="range" id="slider-intensity" min="0" max="2" step="0.02">
    </div>
    <div class="control-group">
        <label>Complexity</label>
        <input type="range" id="slider-freq" min="0.1" max="10" step="0.1">
    </div>
    <div class="control-group">
        <label>Evolution</label>
        <input type="range" id="slider-speed" min="0" max="0.0025" step="0.0001">
    </div>
</div>

<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, particleSystem, analyser, dataArray;
    let particleCount = 15000;
    let initialPositions, positionsArr;
    let time = 0;
    let darkGlowMode = false;
	let gyroX = 0, gyroY = 0; // 儲存陀螺儀數值
	let baseBeta = null, baseGamma = null; // 用來紀錄啟動時的手機姿勢

    let params = { intensity: 0.3, frequency: 2.0, speed: 0.002 };

    // Slider 監聽
	const overlay = document.getElementById('overlay');
    overlay.addEventListener('click', initAudio);
    document.getElementById('slider-intensity').oninput = (e) => params.intensity = parseFloat(e.target.value);
    document.getElementById('slider-freq').oninput = (e) => params.frequency = parseFloat(e.target.value);
    document.getElementById('slider-speed').oninput = (e) => params.speed = parseFloat(e.target.value);

    // 切換模式：點擊畫面
    window.addEventListener('click', (e) => {
        // 如果點擊的是 UI 介面、或是 Overlay 本身、或是 Overlay 還顯示著，就跳出
		if (e.target.closest('#ui-layer') || 
			e.target.id === 'overlay' || 
			document.getElementById('overlay').style.display !== 'none') {
			return;
		}
		toggleDarkGlow();
    });

    function toggleDarkGlow() {
        darkGlowMode = !darkGlowMode;
        if (darkGlowMode) {
            // 黑光模式：使用相乘混合，粒子稍微加大加深
            particleSystem.material.blending = THREE.MultiplyBlending;
            particleSystem.material.opacity = 0.9;
            particleSystem.material.size = 0.02; 
        } else {
            // 普通模式
            particleSystem.material.blending = THREE.NormalBlending;
            particleSystem.material.opacity = 0.6;
            particleSystem.material.size = 0.015;
        }
        particleSystem.material.needsUpdate = true;
    }
	
	function syncSliders() {
    const sliders = [
        { id: 'slider-intensity', key: 'intensity' },
        { id: 'slider-freq', key: 'frequency' },
        { id: 'slider-speed', key: 'speed' }
    ];
    
    sliders.forEach(s => {
        const el = document.getElementById(s.id);
        // 自動計算該 slider 範圍的 20%
        const val = parseFloat(el.min) + (parseFloat(el.max) - parseFloat(el.min)) * 0.2;
        el.value = val;
        params[s.key] = val;
    });
}

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        initialPositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            let i3 = i * 3;
            const r = 0.6;
            const theta = Math.acos(2 * Math.random() - 1);
            const phi = 2 * Math.PI * Math.random();
            positions[i3] = r * Math.sin(theta) * Math.cos(phi);
            positions[i3 + 1] = r * Math.sin(theta) * Math.sin(phi);
            positions[i3 + 2] = r * Math.cos(theta);
            initialPositions[i3] = positions[i3];
            initialPositions[i3 + 1] = positions[i3 + 1];
            initialPositions[i3 + 2] = positions[i3 + 2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        positionsArr = geometry.attributes.position.array;

        const material = new THREE.PointsMaterial({
            color: 0x000000, size: 0.015, transparent: true, opacity: 0.6, blending: THREE.NormalBlending
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        window.addEventListener('resize', onWindowResize, false);
		syncSliders();
        animate();
    }

    async function initAudio() {
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'block';
		document.getElementById('mode-hint').style.display = 'block';
		
		// --- 陀螺儀授權請求 (iOS 專用) ---
		if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
			try {
				const permission = await DeviceOrientationEvent.requestPermission();
				if (permission === 'granted') {
					window.addEventListener('deviceorientation', handleOrientation);
				}
			} catch (error) {
				console.error("陀螺儀授權失敗:", error);
			}
		} else {
			// 非 iOS 裝置（如 Android）通常不需要手動授權
			window.addEventListener('deviceorientation', handleOrientation);
		}

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audio = new Audio();
        audio.src = '沒醉.mp3'; 
        audio.crossOrigin = "anonymous";
        audio.loop = true;
        
        const source = audioContext.createMediaElementSource(audio);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);
        analyser.connect(audioContext.destination);

        dataArray = new Uint8Array(analyser.frequencyBinCount);
        if (audioContext.state === 'suspended') await audioContext.resume();
        audio.play();
    }
	
	// 處理陀螺儀數據
	function handleOrientation(event) {
		let x = event.gamma || 0; // 左右 (-90 到 90)
		let y = event.beta || 0;  // 前後 (-180 到 180)

		// 第一筆數據進來時，紀錄為基準點
		if (baseGamma === null) baseGamma = x;
		if (baseBeta === null) baseBeta = y;

		// 計算偏移量 (當前角度 - 基準角度)
		// 我們限制偏移量在一個合理範圍內
		gyroX = Math.max(Math.min((x - baseGamma) / 20, 1.5), -1.5);
		gyroY = Math.max(Math.min((y - baseBeta) / 20, 1.5), -1.5);
	}

    function animate() {
        requestAnimationFrame(animate);
        time += params.speed * 100;

        if (analyser) {
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for (let j = 0; j < dataArray.length; j++) sum += dataArray[j];
            const boost = (sum / dataArray.length) / 255;

            const posAttribute = particleSystem.geometry.attributes.position;
            const freqLen = dataArray.length;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const freqVal = dataArray[i % freqLen] / 255.0;
                const noise = Math.sin(initialPositions[i3] * params.frequency + time) * params.intensity;
                const scale = 1.0 + (freqVal * 3.0) + (boost * 1.0);

                positionsArr[i3]     = initialPositions[i3] * scale + noise;
                positionsArr[i3 + 1] = initialPositions[i3 + 1] * scale + noise;
                positionsArr[i3 + 2] = initialPositions[i3 + 2] * scale + noise;
            }
            posAttribute.needsUpdate = true;
            
			// --- 核心修改：視角偏移效果 ---
			// 1. 設定目標位置 (Z 軸維持在 3，XY 軸隨陀螺儀偏移)
			const targetCamX = gyroX * 1.2; 
			const targetCamY = -gyroY * 1.2; // 這裡是負號，讓手機往上抬時視角往下看，產生視差

			// 2. 絲滑移動 (Lerp): 當前位置 + (目標 - 當前) * 係數
			camera.position.x += (targetCamX - camera.position.x) * 2;
			camera.position.y += (targetCamY - camera.position.y) * 2;

			// 3. 永遠盯著中心點，這會產生強烈的立體透視感
			camera.lookAt(0, 0, 0);
			
            particleSystem.rotation.y += 0.005 + (gyroY * 0.1); // 隨左右傾斜加速旋轉
			particleSystem.rotation.x += 0.002 - (gyroX * 0.1); // 隨前後傾斜加速旋轉

            // 如果音樂超響，背景變稍微深一點點來強調「黑光」
            if (boost > 0.42) scene.background.set(darkGlowMode ? 0xeeeeee : 0xfcfcfc);
            else scene.background.set(0xffffff);
        } else {
            particleSystem.rotation.y += 0.002;
			particleSystem.rotation.x += 0.001;
        }
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
</script>
</body>
</html>
