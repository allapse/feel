<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><path d='M40 10 L95 75 L45 95 Z' fill='%23666'/><path d='M40 10 L5 65 L45 95 Z' fill='%23333'/><path d='M45 95 L5 65 L95 75 Z' fill='%23000' fill-opacity='0.7'/></svg>">
    <title>SOBER</title>
    <link rel="stylesheet" href="css/ui.css">
</head>
<body>

<div id="overlay" style="white-space: pre;">    S O B E R    </div>
<div id="mode-hint">TAP TO GLOW</div>
<div id="link">MISSING</div>

<div id="ui-layer" style="display: none;"></div>
<script src="js/util.js"></script>
<script type="module">
	// 1. 參數定義
	const params = { intensity: 0.3, frequency: 2.0, speed: 0.002 };
	window.params = params;

	// 2. 初始化中樞
	const audioMap = new AudioMap(params);
	window.audioMap = audioMap;

	// 3. 生成 UI (此時 ID 自動與 config 掛鉤)
	audioMap.buildUI('ui-layer', [
		{ id: 'ui-intensity', key: 'intensity', label: 'Distortion', min: 0, max: 2, step: 0.02, range: [61, 100] },
		{ id: 'ui-freq', key: 'frequency', label: 'Complexity', min: 0.1, max: 10, step: 0.1, range: [0, 40] },
		{ id: 'ui-speed', key: 'speed', label: 'Evolution', min: 0, max: 0.0025, step: 0.0001, range: [41, 60] }
	],
	'assets/audio/list.json');
</script>

<div id="container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, particleSystem;
    let particleCount = 15000;
    let initialPositions, positionsArr;
    let time = 0;
    let darkGlowMode = false;
	let orient = { x: 0.5, y: 0.5 };

	let visualBoost = 0;

	const overlay = document.getElementById('overlay');
	overlay.addEventListener('click', async () => {
		audioMap.initAudio('assets/audio/沒醉.mp3')
		await audioMap.initGyro({ range: 20 }, (data) => {
			orient.x = data.x * 1.5;
			orient.y = data.y * 1.5;
		});
	});
	
	const link = document.getElementById('link');
    link.addEventListener('click', function() {
		window.location.assign("missing.html");
	});

    // 1. 同時監聽 click 和 touchend
	['click', 'touchend'].forEach(eventType => {
		window.addEventListener(eventType, (e) => {
			const overlay = document.getElementById('overlay');
			
			// --- 攔截條件 ---
			// 如果 Overlay 還在，不執行切換
			if (overlay && overlay.style.display !== 'none') return;
			// 如果點到 UI 控制板（或是 input），不執行切換
			if (e.target.closest('#ui-layer') || e.target.tagName === 'INPUT') return;
			// 如果點到的是 Overlay 本身（雖然已經隱藏，但作為保險），不執行切換
			if (e.target.id === 'overlay') return;
			if (e.target.closest('#link')) return;

			// --- 執行切換 ---
			toggleDarkGlow();

			// 避免在某些瀏覽器上 click 和 touchend 重複觸發
			if (eventType === 'touchend') {
				// 如果點擊有效，防止後續的 click 事件產生
				// e.preventDefault(); // 注意：若有其他連結需要點擊，可視情況註解此行
			}
		}, { passive: true });
	});

    function toggleDarkGlow() {
        darkGlowMode = !darkGlowMode;
    
		if (darkGlowMode) {
			// --- 進入黑光發光模式 ---
			particleSystem.material.blending = THREE.MultiplyBlending;
			particleSystem.material.size = 0.01;   // 放大粒子，讓邊緣漸層重疊
			particleSystem.material.opacity = 0.3; // 讓黑度更高
		} else {
			// --- 回到普通硬核模式 ---
			particleSystem.material.blending = THREE.NormalBlending;
			particleSystem.material.size = 0.02;   // 縮小，看起來像精細的點
			particleSystem.material.opacity = 0.6;
		}
		particleSystem.material.needsUpdate = true;
    }

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
		const cubeGeo = new THREE.BoxGeometry(2, 2, 2);

		// 2. 提取邊緣線
		const edges = new THREE.EdgesGeometry(cubeGeo);

		// 3. 建立線條材質
		const lineMaterial = new THREE.LineBasicMaterial({ 
			color: 0x000000, 
			linewidth: 2,    // 注意：部分瀏覽器不支援調整粗細，會固定為 1
			transparent: true,
			opacity: 0.3     // 淡淡的邊框最有質感
		});

		// 4. 建立線段物件並加入場景
		const cage = new THREE.LineSegments(edges, lineMaterial);
		scene.add(cage);
		
		window.cage = cage;
		
		// 建立內部背景
		const innerBoxGeo = new THREE.BoxGeometry(1.99, 1.99, 1.99); // 比邊框 2.0 稍微小一點
		const innerBoxMat = new THREE.MeshBasicMaterial({
			color: 0xffffff,
			side: THREE.BackSide, // 關鍵：讓顏色渲染在內壁，才不會擋住粒子
			transparent: true,
			opacity: 0.5
		});
		const innerBox = new THREE.Mesh(innerBoxGeo, innerBoxMat);
		scene.add(innerBox);

		// 為了讓 animate 能存取，記得把它設為全域變數
		window.innerBox = innerBox;

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('container').appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        initialPositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            let i3 = i * 3;
            const r = 0.8;
            const theta = Math.acos(2 * Math.random() - 1);
            const phi = 2 * Math.PI * Math.random();
            positions[i3] = r * Math.sin(theta) * Math.cos(phi);
            positions[i3 + 1] = r * Math.sin(theta) * Math.sin(phi);
            positions[i3 + 2] = r * Math.cos(theta);
            initialPositions[i3] = positions[i3];
            initialPositions[i3 + 1] = positions[i3 + 1];
            initialPositions[i3 + 2] = positions[i3 + 2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        positionsArr = geometry.attributes.position.array;

        const material = new THREE.PointsMaterial({
			color: 0x000000,
			size: 0.02,              // 基礎大小
			map: createCircleTexture(), // 套用剛才畫的漸層貼圖
			transparent: true,
			opacity: 0.6,
			blending: THREE.NormalBlending,
			depthWrite: false,       // 關鍵：這能讓粒子重疊時不會有難看的方塊邊緣
			alphaTest: 0.001         // 確保透明部分的計算更精確
		});

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        window.addEventListener('resize', onWindowResize, false);
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
		
		if(window.params)
			time += window.params.speed * 100;

        if (window.audioMap && window.audioMap.analyser && window.audioMap.dataArray) {
            audioMap.analyser.getByteFrequencyData(audioMap.dataArray);
			
			audioMap.updateAudioReaction(audioMap.dataArray, null);
			audioMap.updateGyroUI(orient);
			
            let sum = 0;
            for (let j = 0; j < audioMap.dataArray.length; j++) sum += audioMap.dataArray[j];
            const boost = (sum / audioMap.dataArray.length) / 255;

            const posAttribute = particleSystem.geometry.attributes.position;
            const freqLen = audioMap.dataArray.length;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const freqVal = audioMap.dataArray[i % freqLen] / 255.0;
                const noise = Math.sin(initialPositions[i3] * params.frequency + time) * params.intensity;
                const scale = 1.0 + (freqVal * 3.0) + (boost * 1.0);

                // 在 animate 迴圈內
				let posX = initialPositions[i3] * scale + noise;
				let posY = initialPositions[i3+1] * scale + noise;
				let posZ = initialPositions[i3+2] * scale + noise;

				const limit = 1.0;
				// 如果超過邊界，增加一個震盪阻力
				if (Math.abs(posX) > limit) posX *= 0.1; 
				if (Math.abs(posY) > limit) posY *= 0.1;
				if (Math.abs(posZ) > limit) posZ *= 0.1;

				positionsArr[i3] = posX;
				positionsArr[i3+1] = posY;
				positionsArr[i3+2] = posZ;
            }
            posAttribute.needsUpdate = true;
            
			// --- 核心修改：視角偏移效果 ---
			// 1. 設定目標位置 (Z 軸維持在 3，XY 軸隨陀螺儀偏移)
			const targetCamX = orient.x * 1.2; 
			const targetCamY = -orient.y * 1.2; // 這裡是負號，讓手機往上抬時視角往下看，產生視差

			// 2. 絲滑移動 (Lerp): 當前位置 + (目標 - 當前) * 係數
			camera.position.x += (targetCamX - camera.position.x) * 0.08;
			camera.position.y += (targetCamY - camera.position.y) * 0.08;

			// 3. 永遠盯著中心點，這會產生強烈的立體透視感
			camera.lookAt(0, 0, 0);
			
            particleSystem.rotation.y += 0.002 - (orient.x * 0.05); // 隨左右傾斜加速旋轉
			particleSystem.rotation.x += 0.001 - (orient.y * 0.05); // 隨前後傾斜加速旋轉

            // 1. 設定一個觸發門檻 (例如 0.4，你可以根據音樂調整)
			const boostThreshold = 0.42; 
			// 只計算超過門檻的部分，並放大它的倍率
			let activeBoost = Math.max(0, boost - boostThreshold) * 2.0;

			// 2. 更新視覺衝擊變數
			if (activeBoost > visualBoost) {
				visualBoost = activeBoost; // 瞬間衝高
			} else {
				visualBoost *= 0.85; // 稍微加快回歸速度，讓閃爍更俐落
			}

			// 3. 只有當 visualBoost 真的有值時才改變顏色與縮放
			if (visualBoost > 0.01) {
				const colorIntensity = 1.0 - (visualBoost * 0.4); 
				innerBox.material.color.setRGB(colorIntensity, colorIntensity, colorIntensity);
				
				const s = 1.0 + (visualBoost * 0.05);
				cage.scale.set(s, s, s);
				cage.material.opacity = 0.3 + (visualBoost * 0.6);
			} else {
				// 平時回歸初始狀態
				innerBox.material.color.setRGB(1, 1, 1);
				cage.scale.set(1, 1, 1);
				cage.material.opacity = 0.3;
			}
        } else {
            particleSystem.rotation.y += 0.002;
			particleSystem.rotation.x += 0.001;
        }
        renderer.render(scene, camera);
    }
	
	function createCircleTexture() {
		const canvas = document.createElement('canvas');
		canvas.width = 64;
		canvas.height = 64;
		const ctx = canvas.getContext('2d');

		// 徑向漸層：中心不透明，邊緣完全透明
		const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
		gradient.addColorStop(0, 'rgba(0,0,0,1)');   // 中心純黑
		gradient.addColorStop(0.2, 'rgba(0,0,0,0.5)'); // 中間過渡
		gradient.addColorStop(1, 'rgba(0,0,0,0)');   // 邊緣消失

		ctx.fillStyle = gradient;
		ctx.fillRect(0, 0, 64, 64);

		const texture = new THREE.CanvasTexture(canvas);
		return texture;
	}

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
</script>
</body>
</html>
