<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Negative Space - Hardcore Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: #999; cursor: pointer; z-index: 10;
            padding: 20px; border: 0px solid #CCC; transition: 0.3s;
        }
        #overlay:hover { background: rgba(0, 0, 0, 0.5); color: #fff; }
    </style>
</head>
<body>

<div id="overlay">CLICK TO UNLEASH THE NOISE</div>
<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, particleSystem, analyser, dataArray;
    let particleCount = 15000;
    let positions, initialPositions;

    const overlay = document.getElementById('overlay');
    overlay.addEventListener('click', initAudio);

    function init() {
        // 1. 場景與渲染器 (純白底)
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 2. 建立粒子 (純黑)
        const geometry = new THREE.BufferGeometry();
        positions = new Float32Array(particleCount * 3);
        initialPositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            let i3 = i * 3;
            // 初始分佈：稍微不規則的球體
            const r = 1;
            const theta = Math.acos(2 * Math.random() - 1);
            const phi = 2 * Math.PI * Math.random();

            positions[i3] = r * Math.sin(theta) * Math.cos(phi);
            positions[i3 + 1] = r * Math.sin(theta) * Math.sin(phi);
            positions[i3 + 2] = r * Math.cos(theta);

            initialPositions[i3] = positions[i3];
            initialPositions[i3 + 1] = positions[i3 + 1];
            initialPositions[i3 + 2] = positions[i3 + 2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: 0x000000,
            size: 0.015,
            transparent: true,
            opacity: 0.6,
            blending: THREE.NormalBlending // 白底下正常的混合模式
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        window.addEventListener('resize', onWindowResize, false);
        animate();
    }

	// 1. 將關鍵變數提升到全域
	let audioContext, audio, source;
	let animationId; // 用來控制動畫循環

	async function initAudio() {
		overlay.style.display = 'none';

		audioContext = new (window.AudioContext || window.webkitAudioContext)({
			sampleRate: 44100,
			latencyHint: 'playback'
		});

		audio = new Audio();
		audio.src = '沒醉.mp3';
		audio.crossOrigin = "anonymous";
		audio.loop = true;

		// 2. 初始化 MediaSession
		if ('mediaSession' in navigator) {
			navigator.mediaSession.metadata = new MediaMetadata({
				title: '沒醉',
				album: 'feel',
				artwork: [{ src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=", sizes: '1x1', type: 'image/png' }]
			});
			navigator.mediaSession.setActionHandler('play', () => audio.play());
			navigator.mediaSession.setActionHandler('pause', () => audio.pause());
		}

		// 3. 初始化節點與數據空間 (確保 dataArray 在這裡被定義)
		source = audioContext.createMediaElementSource(audio);
		analyser = audioContext.createAnalyser();
		analyser.fftSize = 256;
		dataArray = new Uint8Array(analyser.frequencyBinCount); // 這裡初始化！

		// 預設連接
		source.connect(analyser);
		analyser.connect(audioContext.destination);

		// 4. 背景切換的正規處理
		document.addEventListener('visibilitychange', () => {
			if (document.visibilityState === 'hidden') {
				// 背景：斷開分析器避免 iOS 靜音，停止動畫節省效能
				analyser.disconnect();
				source.disconnect();
				source.connect(audioContext.destination);
				cancelAnimationFrame(animationId); 
			} else {
				// 前台：重新連接並啟動動畫
				source.disconnect();
				source.connect(analyser);
				analyser.connect(audioContext.destination);
				audioContext.resume();
				audio.play();
				animate(); // 重新啟動循環
			}
		});

		audio.onplay = () => { navigator.mediaSession.playbackState = "playing"; };
		audio.onpause = () => { navigator.mediaSession.playbackState = "paused"; };

		await audioContext.resume();
		audio.play();
		animate(); // 第一次啟動動畫
	}

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        animationId = requestAnimationFrame(animate);

        if (analyser) {
            analyser.getByteFrequencyData(dataArray);
            
            // 抓取低頻強度作為整體縮放
            const averageFreq = dataArray.reduce((a, b) => a + b) / dataArray.length;
            const boost = averageFreq / 255;

            const posAttribute = particleSystem.geometry.attributes.position;
            const time = Date.now() * 0.002;

            for (let i = 0; i < particleCount; i++) {
                let i3 = i * 3;
                let freqVal = dataArray[i % dataArray.length] / 255.0;

                // 數學混亂邏輯：結合 Sine 波與頻率造成的空間扭曲
                // 當頻率高時，粒子會沿著法線方向劇烈噴射
                let noise = Math.sin(initialPositions[i3] * 2 + time) * 0.1;
                let scale = 1.0 + (freqVal * 1.5) + (boost * 0.5);

                posAttribute.array[i3] = initialPositions[i3] * scale + noise;
                posAttribute.array[i3+1] = initialPositions[i3+1] * scale + noise;
                posAttribute.array[i3+2] = initialPositions[i3+2] * scale + noise;
            }
            
            posAttribute.needsUpdate = true;
            
            // 讓球體緩慢旋轉
            particleSystem.rotation.y += 0.005;
            particleSystem.rotation.x += 0.002;

            // 如果音樂超響，背景稍微閃爍灰色，模擬過曝感
            if (boost > 0.42) {
                scene.background = new THREE.Color(0xdddddd);
            } else {
                scene.background = new THREE.Color(0xffffff);
            }
        }
		else
		{
			// 讓球體緩慢旋轉
            particleSystem.rotation.y += 0.002;
            particleSystem.rotation.x += 0.001;
		}

        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>
