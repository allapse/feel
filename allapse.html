<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALLAPSE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; font-family: 'Courier New', Courier, monospace; cursor: crosshair; }
        #canvas-container { position: fixed; /* 改用 fixed 確保不會隨網頁滾動 */
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			display: block; 
		}
        
        /* 極簡 Slider 樣式 */
        #ui-layer {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 20; color: #999; display: none;
        }
        .control-group { margin-bottom: 20px; }
        label { font-size: 9px; display: block; margin-bottom: 8px; text-transform: uppercase;}
        
        input[type=range] {
            -webkit-appearance: none; width: 180px; background: transparent;
        }
        input[type=range]:focus { outline: none; }
        /* 軌道 */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 1px; background: #999; border: none;
        }
        /* 拉桿 */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 12px; 
            background: #999; cursor: pointer; margin-top: -5.5px;
            border-radius: 0; border: 1px solid #fff;
        }

        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: #999; cursor: pointer; z-index: 100;
            padding: 30px; border: 0px solid #000; transition: 0.4s; letter-spacing: 4px; font-size: 12px;
			background: rgba(0, 0, 0, 0.6);
        }
        #overlay:hover { background: rgba(0, 0, 0, 0.7); color: #fff; }

        #mode-hint {
            position: absolute; bottom: 20px; right: 20px; font-size: 9px; color: #999;
            letter-spacing: 1px; pointer-events: none; display: none; z-index: 100;
        }
		
		#link {
            position: absolute; bottom: 20px; left: 20px; font-size: 9px; color: #999;
            letter-spacing: 1px; pointer-events: auto; display: none; z-index: 101;
        }
		
		#canvas-container { 
			width: 100vw; 
			height: 100vh; 
			touch-action: none; /* 重要：防止瀏覽器攔截觸控事件 */
		}
    </style>
</head>
<body>

<div id="overlay" style="white-space: pre;">  A L L A P S E  </div>
<div id="mode-hint">TAP TO GLOW</div>
<div id="link">SOBER</div>

<div id="ui-layer">
    <div class="control-group">
        <label>Distortion</label>
        <input type="range" id="slider-intensity" min="0" max="2" step="0.02">
    </div>
    <div class="control-group">
        <label>Complexity</label>
        <input type="range" id="slider-freq" min="0.1" max="10" step="0.1">
    </div>
    <div class="control-group">
        <label>Evolution</label>
        <input type="range" id="slider-speed" min="0" max="0.0025" step="0.0001">
    </div>
</div>

<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    let scene, camera, renderer, particleSystem, analyser, dataArray;
    let particleCount = 15000;
    let initialPositions, positionsArr;
    let time = 0;
    let darkGlowMode = false;
	let gyroX = 0, gyroY = 0; // 儲存陀螺儀數值
	let baseBeta = null, baseGamma = null; // 用來紀錄啟動時的手機姿勢

    let params = { intensity: 0.3, frequency: 2.0, speed: 0.002 };
	let visualBoost = 0;
	const primes = [];

    // Slider 監聽
	const overlay = document.getElementById('overlay');
    overlay.addEventListener('click', initAudio);
	const link = document.getElementById('link');
    link.addEventListener('click', function() {
		window.location.assign("index.html");
	});
    document.getElementById('slider-intensity').oninput = (e) => params.intensity = parseFloat(e.target.value);
    document.getElementById('slider-freq').oninput = (e) => params.frequency = parseFloat(e.target.value);
    document.getElementById('slider-speed').oninput = (e) => params.speed = parseFloat(e.target.value);

    // 1. 同時監聽 click 和 touchend
	['click', 'touchend'].forEach(eventType => {
		window.addEventListener(eventType, (e) => {
			const overlay = document.getElementById('overlay');
			
			// --- 攔截條件 ---
			// 如果 Overlay 還在，不執行切換
			if (overlay && overlay.style.display !== 'none') return;
			// 如果點到 UI 控制板（或是 input），不執行切換
			if (e.target.closest('#ui-layer') || e.target.tagName === 'INPUT') return;
			// 如果點到的是 Overlay 本身（雖然已經隱藏，但作為保險），不執行切換
			if (e.target.id === 'overlay') return;
			if (e.target.closest('#link')) return;

			// --- 執行切換 ---
			toggleDarkGlow();

			// 避免在某些瀏覽器上 click 和 touchend 重複觸發
			if (eventType === 'touchend') {
				// 如果點擊有效，防止後續的 click 事件產生
				// e.preventDefault(); // 注意：若有其他連結需要點擊，可視情況註解此行
			}
		}, { passive: true });
	});

    function toggleDarkGlow() {
        darkGlowMode = !darkGlowMode;
    
		if (darkGlowMode) {
			// --- 黑底專用的「能量爆發」模式 ---
			// 在黑底上，發光必須用 Additive，這才是真正的 Glow
			particleSystem.material.blending = THREE.AdditiveBlending;
			particleSystem.material.color.setHex(0xffffff); // 純白或青色
			particleSystem.material.size = 0.024;            // 放大，讓光暈重疊
			particleSystem.material.opacity = 0.72;          // 提高透明度，讓加法效應明顯
		} else {
			// --- 黑底專用的「冷酷數據」模式 ---
			// 保持精確、細小的點
			particleSystem.material.blending = THREE.NormalBlending;
			particleSystem.material.color.setHex(0xffffff); // 灰色點，避免搶走晶格風采
			particleSystem.material.size = 0.02;
			particleSystem.material.opacity = 0.6;
		}
		particleSystem.material.needsUpdate = true;
		particleSystem.material.needsUpdate = true;
    }
	
	// 儲存前一幀的平均頻率
	let audioMappings = []; 
	let prevAverages = {};

	function syncSliders() {
		const sliders = [
			{ id: 'slider-intensity', key: 'intensity', range: [40, 70] }, 
			{ id: 'slider-freq', key: 'frequency', range: [0, 19] },    
			{ id: 'slider-speed', key: 'speed', range: [20, 40] }       
		];

		audioMappings = sliders.map(s => {
			const el = document.getElementById(s.id);
			
			// 監聽手動操作
			el.addEventListener('mousedown', () => el.dataset.isDragging = "true");
			el.addEventListener('touchstart', () => el.dataset.isDragging = "true");
			window.addEventListener('mouseup', () => el.dataset.isDragging = "false");
			window.addEventListener('touchend', () => el.dataset.isDragging = "false");

			return { 
				...s, 
				el: el,
				peak: 100 // 初始預期的最高強度，之後會自動調整
			};
		});
	}

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
		
		// 定義參數
		const count = 5; // 每邊重複次數，總共會有 5^3 = 125 個
		const spacing = 1; // 每個三角形之間的間距
		const instances = [];

		const group = new THREE.Group();
		const tetraGeo = new THREE.TetrahedronGeometry(1, 0); // 半徑1，0細分（純三角形）
		const edgesGeo = new THREE.EdgesGeometry(tetraGeo);

		// 材質保持你原本的質感
		const lineMat = new THREE.LineBasicMaterial({ 
			color: 0x000000, 
			transparent: true, 
			opacity: 0.8
		});
		const meshMat = new THREE.MeshBasicMaterial({
			color: 0x222222,
			side: THREE.BackSide,
			transparent: true,
			opacity: 0.4
		});

		// 建立 3D 矩陣排布
		for (let x = -count; x <= count; x++) {
			for (let y = -count; y <= count; y++) {
				for (let z = -count; z <= count; z++) {
					const mesh = new THREE.Mesh(tetraGeo, meshMat.clone());
					const line = new THREE.LineSegments(edgesGeo, lineMat.clone());
					
                    // 在建立 3D 矩陣的迴圈內
                    const isOuter = Math.abs(x) === count || Math.abs(y) === count || Math.abs(z) === count;

                    if (isOuter) {
                        mesh.material.opacity = 0.9; // 最外層線條完全不透明
                        mesh.material.color.set(0x000000); 
                    } else {
                        mesh.material.opacity = 0.4; // 內層線條淡化，突出結構感
                    }
                    
					const xPos = x * spacing;
					const yPos = y * spacing;
					const zPos = z * spacing;
					
					mesh.position.set(xPos, yPos, zPos);
					line.position.set(xPos, yPos, zPos);
					
					group.add(mesh);
					group.add(line);
					
					// 存入陣列供 animate 存取
					instances.push({ mesh, line, basePos: { x: xPos, y: yPos, z: zPos } });
				}
			}
		}
		scene.add(group);
		window.instances = instances; // 供全域存取
		
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        initialPositions = new Float32Array(particleCount * 3);

        // 找出前 particleCount 個質數並設定位置
		let num = 2;
		while (primes.length < particleCount) {
			if (isPrime(num)) primes.push(num);
			num++;
		}

		// 找出最大質數來做歸一化基準
		const maxP = primes[primes.length - 1];
		const maxRadius = Math.sqrt(maxP);

		for (let i = 0; i < particleCount; i++) {
			let i3 = i * 3;
			const p = primes[i];
			
			// 1. 利用質數的特性產生不對稱的座標
			// 我們使用 p 的正弦與餘弦，但分別給予不同的頻率偏移
			const scale = 1.2;
			positions[i3]     = Math.cos(p * 0.1) * Math.sin(p * 0.3) * scale; // X
			positions[i3 + 1] = Math.sin(p * 0.5) * Math.cos(p * 0.2) * scale; // Y
			positions[i3 + 2] = Math.cos(p * 0.7) * scale;                    // Z

			initialPositions[i3] = positions[i3];
			initialPositions[i3 + 1] = positions[i3 + 1];
			initialPositions[i3 + 2] = positions[i3 + 2];
		}

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        positionsArr = geometry.attributes.position.array;

        const material = new THREE.PointsMaterial({
			color: 0xffffff,
			size: 0.02,              // 基礎大小
			map: createCircleTexture(), // 套用剛才畫的漸層貼圖
			transparent: true,
			opacity: 0.6,
			blending: THREE.NormalBlending,
			depthTest: false,       // 核心：無視黑色的三角體，強行畫在最上層
			depthWrite: false,      // 不受深度緩衝影響
			alphaTest: 0.001         // 確保透明部分的計算更精確
		});

        particleSystem = new THREE.Points(geometry, material);
		// 在建立 particleSystem 之後立即加入
		particleSystem.renderOrder = 999; 
        scene.add(particleSystem);

        window.addEventListener('resize', onWindowResize, false);
		syncSliders();
        animate();
    }
	
	function isPrime(num) {
		for(let i = 2, s = Math.sqrt(num); i <= s; i++)
			if(num % i === 0) return false; 
		return num > 1;
	}

    async function initAudio() {
		// 隱藏/顯示 UI 層
		document.getElementById('overlay').style.display = 'none';
		document.getElementById('ui-layer').style.display = 'block';
		document.getElementById('mode-hint').style.display = 'block';
		document.getElementById('link').style.display = 'block';

		// --- 陀螺儀授權請求 (保持不變) ---
		if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
			try {
				const permission = await DeviceOrientationEvent.requestPermission();
				if (permission === 'granted') {
					window.addEventListener('deviceorientation', handleOrientation);
				}
			} catch (error) {
				console.error("陀螺儀授權失敗:", error);
			}
		} else {
			window.addEventListener('deviceorientation', handleOrientation);
		}

		// --- 核心修改：麥克風輸入 ---
		try {
			const audioContext = new (window.AudioContext || window.webkitAudioContext)();
			
			// 請求麥克風權限
			const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
			
			// 建立麥克風來源
			const source = audioContext.createMediaStreamSource(stream);
			
			analyser = audioContext.createAnalyser();
			analyser.fftSize = 256;
			analyser.smoothingTimeConstant = 0.8; // 讓變動滑順一點，更有「場」的感覺

			source.connect(analyser);
			// 注意：麥克風輸入通常不 connect 到 audioContext.destination (不然會有回授/嘯叫聲)

			dataArray = new Uint8Array(analyser.frequencyBinCount);
			
			if (audioContext.state === 'suspended') await audioContext.resume();
			
			console.log("麥克風已啟動，開始捕捉即時訊號");
		} catch (err) {
			console.error("無法存取麥克風:", err);
			alert("請允許麥克風權限以進行互動。");
		}
	}
	
	// 處理陀螺儀數據
	function handleOrientation(event) {
		let x = event.gamma || 0; // 左右 (-90 到 90)
		let y = event.beta || 0;  // 前後 (-180 到 180)

		// 第一筆數據進來時，紀錄為基準點
		if (baseGamma === null) baseGamma = x;
		if (baseBeta === null) baseBeta = y;

		// 計算偏移量 (當前角度 - 基準角度)
		// 我們限制偏移量在一個合理範圍內
		gyroX = Math.max(Math.min((x - baseGamma) / 20, 1.5), -1.5);
		gyroY = Math.max(Math.min((y - baseBeta) / 20, 1.5), -1.5);
	}

	let crystalFactor = 0;

    function animate() {
        requestAnimationFrame(animate);
        time += params.speed * 100;

        if (analyser) {
            analyser.getByteFrequencyData(dataArray);
			
			audioMappings.forEach(mapping => {
				const el = mapping.el;
				if (el.dataset.isDragging === "true") return;

				// 1. 計算平均值
				let sum = 0;
				for (let i = mapping.range[0]; i <= mapping.range[1]; i++) {
					sum += dataArray[i];
				}
				let currentAvg = sum / (mapping.range[1] - mapping.range[0] + 1);

				// 2. 強化：扣除底噪門檻 (讓數值更有「空間」呼吸)
				const noiseFloor = 30; 
				currentAvg = Math.max(0, currentAvg - noiseFloor);

				// 3. 強化：動態峰值 (快速上升，極慢下降)
				if (currentAvg > mapping.peak) {
					// 即使聲音變大，也不要立刻更新 peak，用一點緩衝
					mapping.peak += (currentAvg - mapping.peak) * 0.2; 
				} else {
					mapping.peak *= 0.99999; // 維持在一個適中的下降速度
				}

				// 4. 【核心關鍵】：非線性縮放 (加上 Power 函數)
				// 透過 Math.pow(ratio, 2)，小聲音會更小，大聲音才有爆發感
				let ratio = currentAvg / (Math.max(mapping.peak, 50));
				ratio = Math.pow(ratio, 1.5); // 數值越大，Slider 越難衝到頂 (1.5 ~ 2.0 效果最佳)

				// 5. 映射與 Lerp
				const min = parseFloat(el.min);
				const max = parseFloat(el.max);
				const targetVal = min + (max - min) * ratio;

				// 降低靈敏度 (從 0.1 降到 0.05)，增加絲滑感
				params[mapping.key] += (targetVal - params[mapping.key]) * 0.1;
				
				el.value = params[mapping.key];
			});
			
            let sum = 0;
            for (let j = 0; j < dataArray.length; j++) sum += dataArray[j];
            const boost = (sum / dataArray.length) / 255;

            const posAttribute = particleSystem.geometry.attributes.position;
            const freqLen = dataArray.length;

            const isClipping = dataArray.some(val => val >= 222);
    
			// --- B. 計算結晶係數 (讓切換更絲滑，不要瞬間跳變) ---
			// 如果溢出，crystalFactor 趨向 1；否則趨向 0
			crystalFactor += (isClipping ? 1.0 - crystalFactor : 0.0 - crystalFactor) * 0.15;

			// --- C. 粒子迴圈 ---
			for (let i = 0; i < particleCount; i++) {
				const i3 = i * 3;
				
				// [原本的發散/扭曲邏輯]
				const f = params.frequency;
				const noise = Math.sin(initialPositions[i3] * f + time) * params.intensity;
				const scale = 1.0 + (dataArray[i % 128] / 255.0) * 3.0 + (boost * 1.5);
				
				const organicX = initialPositions[i3] * scale + noise;
				const organicY = initialPositions[i3+1] * scale + noise;
				const organicZ = initialPositions[i3+2] * scale + noise;

				// 替代方案：讓結晶維持螺旋但變得「極度規整」
				const angle = Math.sqrt(i) * Math.PI * 2;
				const radius = Math.sqrt(i) * 0.0025;
				const height = i * 0.25;

				const gridX = Math.cos(angle) * radius;
				const gridY = Math.sin(angle) * radius;
				const gridZ = height - (particleCount * 0.01) / 2; // 垂直拉伸成柱狀晶體

				// 在 positionsArr 賦值時
				// 讓 X, Y, Z 的結晶速度稍微錯開，產生一種扭曲著被吸進去的感覺
                // 關鍵：確保 crystalFactor 數值合法
                const safeFactor = Math.max(0, Math.min(1, crystalFactor || 0));
    
				const timingX = Math.pow(safeFactor, 1.2);
				const timingY = Math.pow(safeFactor, 1.5);
				const timingZ = Math.pow(safeFactor, 1.8);

				positionsArr[i3] = organicX * (1 - timingX) + gridX * timingX;
				positionsArr[i3+1] = organicY * (1 - timingY) + gridY * timingY;
				positionsArr[i3+2] = organicZ * (1 - timingZ) + gridZ * timingZ;
			}
			posAttribute.needsUpdate = true;
			
			// 在 animate 粒子迴圈內
			for (let i = 0; i < particleCount; i++) {
				let i3 = i * 3;
				const p = primes[i];
				
				// 取得當前粒子座標
				let x = positionsArr[i3];
				let y = positionsArr[i3+1];
				let z = positionsArr[i3+2];

				// 計算粒子到中心點的距離
				const dist = Math.sqrt(x*x + y*y + z*z);
				
				// 假設三角體的邊界半徑是 1.0
				// 當粒子靠近「空間原子」的邊界時，產生視覺反應
				if (Math.abs(dist - 1.0) < 0.1) {
					// 讓邊界上的質數受麥克風(visualBoost)影響更劇烈
					positionsArr[i3] += Math.sin(time + p) * visualBoost * 0.1;
				}
			}
            
			// --- 核心修改：視角偏移效果 ---
			// 1. 設定目標位置 (Z 軸維持在 3，XY 軸隨陀螺儀偏移)
			const targetCamX = gyroX * 1.2; 
			const targetCamY = -gyroY * 1.2; // 這裡是負號，讓手機往上抬時視角往下看，產生視差

			// 2. 絲滑移動 (Lerp): 當前位置 + (目標 - 當前) * 係數
			camera.position.x += (targetCamX - camera.position.x) * 0.08;
			camera.position.y += (targetCamY - camera.position.y) * 0.08;

			// 3. 永遠盯著中心點，這會產生強烈的立體透視感
			camera.lookAt(0, 0, 0);
			
            particleSystem.rotation.y += 0.002 - (gyroX * 0.05); // 隨左右傾斜加速旋轉
			particleSystem.rotation.x += 0.001 - (gyroY * 0.05); // 隨前後傾斜加速旋轉

            // 1. 設定一個觸發門檻 (例如 0.4，你可以根據音樂調整)
			const boostThreshold = 0.32; 
			// 只計算超過門檻的部分，並放大它的倍率
			let activeBoost = Math.max(0, boost - boostThreshold) * 2.0;

			// 2. 更新視覺衝擊變數
			if (activeBoost > visualBoost) {
				visualBoost = activeBoost; // 瞬間衝高
			} else {
				visualBoost *= 0.85; // 稍微加快回歸速度，讓閃爍更俐落
			}
			
			const shake = (Math.random() - 0.5) * visualBoost * 0.5;
			camera.position.x += (targetCamX - camera.position.x) * 0.08 + shake;
			camera.position.y += (targetCamY - camera.position.y) * 0.08 + shake;

			// 在 animate 函數內
			if (window.instances) {
				window.instances.forEach((inst, index) => {
					const { mesh, line, basePos } = inst;
					
					// 基礎旋轉：讓每個三角形根據其位置有微小的旋轉差（這就是立體感的來源）
					const time = Date.now() * 0.001;
					const offset = (basePos.x + basePos.y + basePos.z) * 0.2;
					
					mesh.rotation.x = line.rotation.x = time * 0.5 + offset;
					mesh.rotation.y = line.rotation.y = time * 0.3 + offset;

					const baseGray = 0.13;
					
					if (visualBoost > 0.01) {
						// 1. 顏色反應 (變深)
						const intensity = Math.max(0, baseGray - (visualBoost * 0.2)); 
						mesh.material.color.setRGB(intensity, intensity, intensity);
						
						// 2. 縮放反應 (根據位置產生不同的縮放波浪，更有立體感)
						const s = 1.0 + (visualBoost * 0.2); 
						mesh.scale.set(s, s, s);
						line.scale.set(s, s, s);
						
						// 3. 透明度反應
						line.material.opacity = 0.3 + (visualBoost * 0.6);
						
						// 附加：位置微震動 (撕掉靜止標籤)
						mesh.position.x = basePos.x + Math.sin(time * 10 + index) * visualBoost * 0.5;
					} else {
						// 回歸初始狀態
						mesh.material.color.setRGB(baseGray, baseGray, baseGray);
						mesh.scale.set(1, 1, 1);
						line.scale.set(1, 1, 1);
						line.material.opacity = 0.3;
						mesh.position.x = basePos.x;
					}
				});
			}
        } else {
            particleSystem.rotation.y += 0.002;
			particleSystem.rotation.x += 0.001;
        }
        renderer.render(scene, camera);
    }
	
	function createCircleTexture() {
		const canvas = document.createElement('canvas');
		canvas.width = 64;
		canvas.height = 64;
		const ctx = canvas.getContext('2d');

		const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
		// 確保這裡是用白色 (1.0) 到 透明 (0.0)
		gradient.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
		gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

		ctx.fillStyle = gradient;
		ctx.fillRect(0, 0, 64, 64);

		const texture = new THREE.CanvasTexture(canvas);
		return texture;
	}

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    init();
</script>
</body>
</html>
