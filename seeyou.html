<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><path d='M40 10 L95 75 L45 95 Z' fill='%23666'/><path d='M40 10 L5 65 L45 95 Z' fill='%23333'/><path d='M45 95 L5 65 L95 75 Z' fill='%23000' fill-opacity='0.7'/></svg>">
    <title>SEE YOU</title>
    <link rel="stylesheet" href="css/ui.css">
</head>
<body>
	<div id="overlay" style="white-space: pre;">  S E E   Y O U  </div>
	<div id="mode-hint" display="none">TAP TO GLOW</div>
	<div id="link">GIVE Z</div>

	<div id="ui-layer" style="display: none;"></div>
	<script src="js/util.js"></script>
	<script type="module">
		// 1. 參數定義
		const params = { intensity: 0, speed: 0, complexity: 0.1 };
		window.params = params;
		let orient = { x: 0.0, y: 0.0 };
		window.orient = orient;

		// 2. 初始化中樞
		const audioMap = new AudioMap(params);
		window.audioMap = audioMap;
		
		// 3. 生成 UI (此時 ID 自動與 config 掛鉤)
		await audioMap.buildUI('ui-layer', [
			{ id: 'ui-intensity', key: 'intensity', label: 'Distortion', min: 0, max: 2, step: 0.02, range: [71, 100] },
			{ id: 'ui-speed', key: 'speed', label: 'Evolution', min: 0, max: 0.0025, step: 0.0001, range: [31, 70] },
			{ id: 'ui-complexity', key: 'complexity', label: 'Complexity', min: 0.1, max: 10, step: 0.1, range: [0, 30] },
		],
		'assets/audio/list.json');
	</script>

	<div id="container"></div>

    <script type="importmap">
        { "imports": { "three": "https://esm.sh/three@0.160.0" } }
    </script>

    <script type="module">
		import * as THREE from 'three';

		// --- 全域變數 ---
		let renderer, scene, camera, material;
		let darkGlowMode = false;

		const _VS = `void main() { gl_Position = vec4(position, 1.0); }`;
		const _FS = `
			precision highp float;
			uniform vec2 u_res;
			uniform float u_time;
			uniform float u_volume;
			uniform float u_volume_smooth;
			uniform float u_last_volume;
			uniform vec2 u_orient;
			uniform float u_intensity;
			uniform float u_complexity;
			uniform float u_speed;
			uniform float u_darkGlow;

			// --- 工具函數 ---
			float noise(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
			float smin(float a, float b, float k) {
				float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
				return mix(b, a, h) - k * h * (1.0 - h);
			}
			vec2 rotate(vec2 p, float a) {
				float s = sin(a), c = cos(a);
				return mat2(c, -s, s, c) * p;
			}

			// SDF 電話聽筒
			float sdPhone(vec2 p) {
				p.x = abs(p.x);
				float body = length(p - vec2(0.1, clamp(p.y, -0.3, 0.3))) - 0.15;
				float speaker = length(p - vec2(0.25, 0.4)) - 0.12;
				float mic = length(p - vec2(0.25, -0.4)) - 0.12;
				return smin(body, smin(speaker, mic, 0.1), 0.1);
			}

			// 核心繪製：牆面與幾何體
			vec4 drawWall(vec2 coords, float depth, float vol, float volSmooth, float volLast, vec2 lookDir) {
				// 1. 數值避震器：限制每一幀的變化幅度不超過 0.05
				// 這能強行把「跳躍」變成「滑動」
				float filteredVol = volLast + clamp(vol - volLast, -0.000001, 0.000001);

				// 2. 使用這個被電視算法「補過」的數值
				float snap = pow(filteredVol, 3.0);
				vec2 p = (coords - 0.5) * (1.0 - snap * 0.3);
				p = abs(p);
				// 16.0 太碎，8.0 剛剛好，配上 4.0 的次方強化「黏滯感」
				float beatTime = floor(u_time * 8.0) / 8.0;
				float bouncyTime = mix(u_time, u_time, 0.6);
				
				// 聲波扭曲
				float wave = sin(p.x * 20.0 + bouncyTime * 20.0) * snap * 1.0;
				vec2 distortedP = p + vec2(0.0, wave);
				
				// SDF 數位流體
				vec2 sdfP = p * 2.0 + lookDir * 0.5;
				sdfP = rotate(sdfP, u_time * 0.5 + depth * 0.2);
				float shape1 = sdPhone(sdfP * (1.0 + vol)); 
				float shape2 = length(sdfP - vec2(sin(u_time), cos(u_time))*0.5) - 0.1;
				float digitalSDF = smin(shape1, shape2, 0.3 + u_complexity*0.1);

				// 光學與色彩
				float glow = 0.01 / (abs(digitalSDF) + 0.01);
				vec3 speedShift = mix(vec3(0.0, 0.15, 0.1), vec3(0.1, 0.0, 0.2), u_speed * 100.0);
				//vec3 col = speedShift;
				vec3 col = speedShift;
				
				vec3 dynamicGlowCol = mix(vec3(0.0, 1.0, 0.6), vec3(1.0, 0.05, 0.4), snap * 2.0);
				col += (dynamicGlowCol + vec3(1.0, 0.05, 0.2)) * glow * (vol + 0.5);
				
				// 網格波動 (Grid)
				vec2 gridUV = distortedP * 15.0; 
				gridUV.y += sin(gridUV.x * 0.5 + u_time * 5.0) * snap * 2.0;
				float gridLines = smoothstep(0.0, 0.1, abs(sin(gridUV.x * 3.14159))) + smoothstep(0.0, 0.1, abs(sin(gridUV.y * 3.14159)));
				col += vec3(0.1, 0.5, 1.0) * (2.0 - gridLines) * (vol + 0.2);

				// 孔洞邏輯 (InHole)
				float angle = atan(distortedP.y, distortedP.x);
				float holeDist = length(distortedP) + sin(angle * 10.0 + bouncyTime + depth * 0.5) * u_intensity * 0.1 * vol;
				float inHole = smoothstep(0.8, 0.22, holeDist);

				return vec4(col, inHole);
				//vec4(vec3(filteredVol * 10.0), 1.0);
			}

			// 渲染整個隧道 (封裝原本 main 裡的循環)
			vec3 renderScene(vec2 uv, vec2 lookDir) {
				vec3 finalCol = vec3(0.0);
				vec2 currentUV = uv;
				float hitDeepest = 0.0;

				for (int i = 0; i < 15; i++) {
					float fi = float(i);
					vec2 layerUV = currentUV + lookDir * fi * 0.04;
					layerUV = (layerUV - 0.5) * (1.0 + dot(layerUV - 0.5, lookDir) * 0.3) + 0.5;

					vec4 layer = drawWall(layerUV, fi, u_volume, u_volume_smooth, u_last_volume, lookDir);
					
					// 丁達爾光柱 (層級投影)
					float lightShaft = smoothstep(0.3, 0.0, layer.a); 
					finalCol += vec3(0.4, 1.0, 0.8) * lightShaft * (1.0 - fi/15.0) * (u_volume + 0.2);

					finalCol += layer.rgb * pow(1.0 - fi / 15.0, 0.5);

					if (layer.a < 0.5) { hitDeepest = 1.0; break; }
					currentUV = rotate(layerUV - 0.5, 0.2 + u_time * 0.2 + fi * 0.05) * 1.15 + 0.5;
				}

				if (hitDeepest > 0.5) {
					float dToCenter = length(currentUV - 0.5);
					finalCol += vec3(0.0, 0.8, 1.0) * exp(-dToCenter * (5.0 - u_volume * 0.1)) * (u_volume * 2.0 + 0.5);
				}
				return finalCol;
			}

			void main() {
				vec2 uv = gl_FragCoord.xy / u_res.xy;
				vec2 lookDir = u_orient;
				
				// 1. 渲染基礎場景
				vec3 finalCol = renderScene(uv, lookDir);
				
				// 2. 抖音感：後處理丁達爾 (降低採樣以保證效能)
				vec3 tyndallEffect = vec3(0.0);
				vec2 rayDir = (uv - 0.5) * 0.15;
				float snap = pow(u_volume, 3.0);

				for (float i = 0.0; i < 1.0; i += 0.125) { // 8 次採樣，兼顧效能與品質
					vec2 sampleUV = uv - rayDir * i;
					// 這裡改為調用渲染後的場景，但為避免死循環，我們只對單層採樣
					vec4 sampleCol = drawWall(sampleUV, 7.0, u_volume, u_volume_smooth, u_last_volume, lookDir);
					
					// 色散效果
					float r = drawWall(sampleUV - rayDir * 0.02, 7.0, u_volume, u_volume_smooth, u_last_volume, lookDir).r;
					float b = drawWall(sampleUV + rayDir * 0.02, 7.0, u_volume, u_volume_smooth, u_last_volume, lookDir).b;
					
					vec3 brightPart = vec3(r, sampleCol.g, b);
					tyndallEffect += brightPart * smoothstep(0.4, 1.2, length(brightPart)) * (1.0 - i);
				}
				finalCol += (tyndallEffect * 0.125) * (snap * 4.0);

				// 3. DarkGlow 模式
				if (u_darkGlow < 0.5) {
					float luminance = dot(finalCol, vec3(0.2126, 0.7152, 0.0722));
					finalCol = vec3(pow(1.0 - luminance, 1.0)) * vec3(1.0, 0.4, 0.8);
				}

				gl_FragColor = vec4(finalCol, 1.0);
			}
		`;
		
		// Slider 監聽
		const overlay = document.getElementById('overlay');
		overlay.addEventListener('click', async () => {
			try {
				// 1. 先啟動音訊 Context (解決 Mic 與播放問題)
				await audioMap.initAudio('assets/audio/再見.mp3');

				// 2. 啟動陀螺儀 (傳回 success 狀態)
				const gyro = await audioMap.initGyro({ range: 20 }, (data) => {
					// 建議在 data.x 傳出前已經在 initGyro 內部處理好基準點偏移
					orient.x = data.x * 1.5;
					orient.y = data.y * 1.5;
				});

				// 3. 只有成功啟動才關閉遮罩
				if (gyro.success) {
					overlay.style.display = 'none';
				}
			} catch (e) {
				console.error("啟動失敗", e);
			}
		});
		const link = document.getElementById('link');
		link.addEventListener('click', function() {
			window.location.assign("givez.html");
		});

		// 1. 同時監聽 click 和 touchend
		['click', 'touchend'].forEach(eventType => {
			window.addEventListener(eventType, (e) => {
				const overlay = document.getElementById('overlay');
				
				// --- 攔截條件 ---
				// 如果 Overlay 還在，不執行切換
				if (overlay && overlay.style.display !== 'none') return;
				// 如果點到 UI 控制板（或是 input），不執行切換
				if (e.target.closest('#ui-layer') || e.target.tagName === 'INPUT') return;
				// 如果點到的是 Overlay 本身（雖然已經隱藏，但作為保險），不執行切換
				if (e.target.id === 'overlay') return;
				if (e.target.closest('#link')) return;

				// --- 執行切換 ---
				toggleDarkGlow();

				// 避免在某些瀏覽器上 click 和 touchend 重複觸發
				if (eventType === 'touchend') {
					// 如果點擊有效，防止後續的 click 事件產生
					// e.preventDefault(); // 注意：若有其他連結需要點擊，可視情況註解此行
				}
			}, { passive: true });
		});
		
		function toggleDarkGlow() {
			darkGlowMode = !darkGlowMode;
			// 將布林值轉為 0.0 或 1.0 傳給 Shader
			material.uniforms.u_darkGlow.value = darkGlowMode ? 1.0 : 0.0;
		}
		
		// 2. 初始化 Three.js 環境
		function init() {
			scene = new THREE.Scene();
			camera = new THREE.Camera(); // 正交相機，適合全螢幕 Shader
			
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.getElementById('container').appendChild(renderer.domElement);

			// 關鍵：在 Three.js 中定義 Uniforms
			material = new THREE.ShaderMaterial({
				uniforms: {
					u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
					u_time: { value: 0.0 },
					u_volume: { value: 0.0 },
					u_volume_smooth: { value: 0.0 },
					u_last_volume: { value: 0.0 },
					u_orient: { value: new THREE.Vector2(0.5, 0.5) },
					// --- 加入 UI 參數 ---
					u_intensity: { value: params.intensity },
					u_complexity: { value: params.complexity },
					u_speed: { value: params.speed },
					u_darkGlow: { value: 0.0 }
				},
				vertexShader: _VS,
				fragmentShader: _FS
			});

			const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
			scene.add(mesh);
			
			animate();
		}
		
		let smoothedVolume = 0;
		let lastVolume = 0;
		
		// 3. Three.js 的渲染循環 (取代你原本手寫的 render)
		function animate(time) {
			requestAnimationFrame(animate);

			// 更新時間
			material.uniforms.u_time.value += 0.01 + params.speed * 5;

			// 更新音量
			if (audioMap && audioMap.analyser && audioMap.dataArray) {
				audioMap.analyser.getByteFrequencyData(audioMap.dataArray);
				let sum = 0;
				for (let i = 0; i < audioMap.dataArray.length; i++) sum += audioMap.dataArray[i];
				let currentTarget = sum / audioMap.dataArray.length / 255.0;
				smoothedVolume += (currentTarget - smoothedVolume) * 0.15;
				material.uniforms.u_volume.value = currentTarget;
				material.uniforms.u_volume_smooth.value = Math.pow(smoothedVolume, 1.5) * 1.5;
				material.uniforms.u_last_volume.value = lastVolume;
				lastVolume = currentTarget;
				
				audioMap.updateAudioReaction(audioMap.dataArray, null);
				audioMap.updateGyroUI(orient);
			}

			// 更新陀螺儀
			material.uniforms.u_orient.value.set(orient.x, orient.y);
			material.uniforms.u_intensity.value = params.intensity;
			material.uniforms.u_complexity.value = params.complexity;
			material.uniforms.u_speed.value = params.speed;

			renderer.render(scene, camera);
		}

		// 啟動
		init();

		window.onresize = () => {
			renderer.setSize(window.innerWidth, window.innerHeight);
			material.uniforms.u_res.value.set(window.innerWidth, window.innerHeight);
		};
    </script>
</body>
</html>






