<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><path d='M40 10 L95 75 L45 95 Z' fill='%23666'/><path d='M40 10 L5 65 L45 95 Z' fill='%23333'/><path d='M45 95 L5 65 L95 75 Z' fill='%23000' fill-opacity='0.7'/></svg>">
    <title>GLIDING</title>
    <link rel="stylesheet" href="css/ui.css">
</head>
<body>
	<div id="overlay" style="white-space: pre;">  G L I D I N G  </div>
	<div id="mode-hint" display="none">TAP TO GLOW</div>
	<div id="link">SOBER</div>

	<div id="ui-layer" style="display: none;"></div>
	<script src="js/util.js"></script>
	<script type="module">
		// 1. 參數定義
		const params = { intensity: 0.3, frequency: 2.0, speed: 0.002 };
		window.params = params;
		let orient = { x: 0.0, y: 0.0 };
		window.orient = orient;

		// 2. 初始化中樞
		const audioMap = new AudioMap(params);
		window.audioMap = audioMap;
		
		// 3. 生成 UI (此時 ID 自動與 config 掛鉤)
		await audioMap.buildUI('ui-layer', [
			{ id: 'ui-intensity', key: 'intensity', label: 'Distortion', min: 0, max: 2, step: 0.02, range: [71, 100] },
			{ id: 'ui-freq', key: 'frequency', label: 'Complexity', min: 0.1, max: 10, step: 0.1, range: [0, 30] },
			{ id: 'ui-speed', key: 'speed', label: 'Evolution', min: 0, max: 0.0025, step: 0.0001, range: [31, 70] },
		],
		'assets/audio/list.json');
	</script>

	<div id="container"></div>

    <script type="importmap">
        { "imports": { "three": "https://esm.sh/three@0.160.0" } }
    </script>

    <script type="module">
		import * as THREE from 'three';

		// --- 全域變數 ---
		let renderer, scene, camera, material;
		let darkGlowMode = false;

		const _VS = `void main() { gl_Position = vec4(position, 1.0); }`;
		const _FS = `
			precision highp float;
			uniform vec2 u_res;
			uniform float u_time;
			uniform float u_volume;
			uniform float u_volume_smooth;
			uniform vec2 u_orient;

			mat2 rot(float a) {
				float s = sin(a), c = cos(a);
				return mat2(c, -s, s, c);
			}

			float map(vec3 p) {
				// 修正 1：對時間取模，防止數值過大導致手機計算崩潰
				float t = mod(u_time, 62.83); 
				
				// 建立隧道
				float tunnel = -(length(p.xy) - 1.5); 
				
				// 加上音樂波紋
				tunnel += sin(p.z * 2.0 - t * 10.0) * u_volume_smooth * 0.3;
				
				// 加上格線
				float grid = sin(atan(p.y, p.x) * 10.0) * sin(p.z * 2.0) * 0.1;
				return tunnel + grid;
			}

			void main() {
				// 修正 2：避免除以零，加上 0.0001
				vec2 uv = (gl_FragCoord.xy - 0.5 * u_res.xy) / (min(u_res.y, u_res.x) + 0.0001);
				
				// 修正 3：防止 u_time 導致 ro 座標過大，同樣取模
				float scrollTime = mod(u_time, 100.0);
				vec3 ro = vec3(0.0, 0.0, scrollTime * 5.0); 
				
				// 修正 4：確保 normalize 的向量不是零向量
				vec2 look = u_orient;
				vec3 rd = normalize(vec3(uv + look * 1.2, 1.0)); 
				
				rd.xy *= rot(look.x * 0.5);
				
				float t = 0.0;
				float glow = 0.0;
				
				// 修正 5：手機通常限制 Loop 次數，32~40 是安全範圍
				for(int i = 0; i < 40; i++) {
					vec3 p = ro + rd * t;
					float d = map(p);
					
					// 累積光流
					float layerGlow = 0.05 / (abs(d) + 0.05);
					glow += layerGlow * (0.1 + u_volume_smooth);
					
					// 修正 6：如果 d 變號，代表穿過物體，立刻停止
					if (abs(d) < 0.001 || t > 15.0) break;
					t += d * 0.6; 
				}
				
				// 修正 7：顏色計算加入時間保護
				float colorTime = mod(u_time * 0.1, 6.28);
				vec3 baseCol = mix(vec3(0.0, 0.8, 1.0), vec3(0.8, 0.0, 1.0), sin(t * 0.1 + colorTime) * 0.5 + 0.5);
				
				float lines = smoothstep(0.9, 1.0, sin(atan(rd.y, rd.x) * 20.0 + u_time * 20.0));
				vec3 col = baseCol * glow * 0.2;
				col += baseCol * lines * u_volume * 0.5;
				
				// 修正 8：手機上的 smoothstep 邊界不能相等
				col *= smoothstep(0.0, 0.8, length(uv + look) + 0.1);
				
				// 加上一點基礎亮度防止全黑
				col += baseCol * 0.05;

				gl_FragColor = vec4(col, 1.0);
			}
		`;
		
		// Slider 監聽
		const overlay = document.getElementById('overlay');
		overlay.addEventListener('click', async () => {
			try {
				// 1. 先啟動音訊 Context (解決 Mic 與播放問題)
				await audioMap.initAudio('mic');

				// 2. 啟動陀螺儀 (傳回 success 狀態)
				const gyro = await audioMap.initGyro({ range: 20 }, (data) => {
					// 建議在 data.x 傳出前已經在 initGyro 內部處理好基準點偏移
					orient.x = data.x * 1.5;
					orient.y = data.y * 1.5;
				});

				// 3. 只有成功啟動才關閉遮罩
				if (gyro.success) {
					overlay.style.display = 'none';
				}
			} catch (e) {
				console.error("啟動失敗", e);
			}
		});
		const link = document.getElementById('link');
		link.addEventListener('click', function() {
			window.location.assign("index.html");
		});

		// 1. 同時監聽 click 和 touchend
		['click', 'touchend'].forEach(eventType => {
			window.addEventListener(eventType, (e) => {
				const overlay = document.getElementById('overlay');
				
				// --- 攔截條件 ---
				// 如果 Overlay 還在，不執行切換
				if (overlay && overlay.style.display !== 'none') return;
				// 如果點到 UI 控制板（或是 input），不執行切換
				if (e.target.closest('#ui-layer') || e.target.tagName === 'INPUT') return;
				// 如果點到的是 Overlay 本身（雖然已經隱藏，但作為保險），不執行切換
				if (e.target.id === 'overlay') return;
				if (e.target.closest('#link')) return;

				// --- 執行切換 ---
				toggleDarkGlow();

				// 避免在某些瀏覽器上 click 和 touchend 重複觸發
				if (eventType === 'touchend') {
					// 如果點擊有效，防止後續的 click 事件產生
					// e.preventDefault(); // 注意：若有其他連結需要點擊，可視情況註解此行
				}
			}, { passive: true });
		});
		
		function toggleDarkGlow() {
			darkGlowMode = !darkGlowMode;
			// 將布林值轉為 0.0 或 1.0 傳給 Shader
			material.uniforms.u_darkGlow.value = darkGlowMode ? 1.0 : 0.0;
		}
		
		// 2. 初始化 Three.js 環境
		function init() {
			scene = new THREE.Scene();
			camera = new THREE.Camera(); // 正交相機，適合全螢幕 Shader
			
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.getElementById('container').appendChild(renderer.domElement);

			// 關鍵：在 Three.js 中定義 Uniforms
			material = new THREE.ShaderMaterial({
				uniforms: {
					u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
					u_time: { value: 0.0 },
					u_volume: { value: 0.0 },
					u_volume_smooth: { value: 0.0 },
					u_last_volume: { value: 0.0 },
					u_orient: { value: new THREE.Vector2(0.5, 0.5) },
					// --- 加入 UI 參數 ---
					u_intensity: { value: params.intensity },
					u_complexity: { value: params.frequency },
					u_speed: { value: params.speed },
					u_darkGlow: { value: 0.0 }
				},
				vertexShader: _VS,
				fragmentShader: _FS
			});

			const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
			scene.add(mesh);
			
			animate();
		}
		
		let smoothedVolume = 0;
		let lastVolume = 0;
		
		// 3. Three.js 的渲染循環 (取代你原本手寫的 render)
		function animate(time) {
			requestAnimationFrame(animate);

			// 更新時間
			material.uniforms.u_time.value += 0.01 + params.speed * 5;

			// 更新音量
			if (audioMap && audioMap.analyser && audioMap.dataArray) {
				audioMap.analyser.getByteFrequencyData(audioMap.dataArray);
				let sum = 0;
				for (let i = 0; i < audioMap.dataArray.length; i++) sum += audioMap.dataArray[i];
				let currentTarget = sum / audioMap.dataArray.length / 255.0;
				smoothedVolume += (currentTarget - smoothedVolume) * 0.15;
				material.uniforms.u_volume.value = currentTarget;
				material.uniforms.u_volume_smooth.value = Math.pow(smoothedVolume, 1.5) * 1.5;
				material.uniforms.u_last_volume.value = lastVolume;
				lastVolume = currentTarget;
				
				audioMap.updateAudioReaction(audioMap.dataArray, null);
				audioMap.updateGyroUI(orient);
			}

			// 更新陀螺儀
			material.uniforms.u_orient.value.set(orient.x, orient.y);
			material.uniforms.u_intensity.value = params.intensity;
			material.uniforms.u_complexity.value = params.frequency;
			material.uniforms.u_speed.value = params.speed;

			renderer.render(scene, camera);
		}

		// 啟動
		init();

		window.onresize = () => {
			renderer.setSize(window.innerWidth, window.innerHeight);
			material.uniforms.u_res.value.set(window.innerWidth, window.innerHeight);
		};
    </script>
</body>
</html>
