<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><path d='M40 10 L95 75 L45 95 Z' fill='%23666'/><path d='M40 10 L5 65 L45 95 Z' fill='%23333'/><path d='M45 95 L5 65 L95 75 Z' fill='%23000' fill-opacity='0.7'/></svg>">
    <title>LOOP</title>
    <link rel="stylesheet" href="css/ui.css">
</head>
<body>
	<div id="overlay" style="white-space: pre;">    L O O P    </div>
	<div id="mode-hint" display="none">TAP TO GLOW</div>
	<div id="link">SOBER</div>

	<div id="ui-layer" style="display: none;"></div>
	<script src="js/util.js"></script>
	<script>
		// 1. 參數定義
		const params = { intensity: 0.3, frequency: 2.0, speed: 0.002 };
		let baseBeta = null, baseGamma = null; // 用來紀錄啟動時的手機姿勢
		let orient = { x: 0.5, y: 0.5 };
		
		function handleOrientation(event) {
			let x = event.gamma || 0; // 左右
			let y = event.beta || 0;  // 前後

			// 1. 紀錄第一筆數據作為基準
			if (baseGamma === null) baseGamma = x;
			if (baseBeta === null) baseBeta = y;

			// 2. 計算相對於基準點的偏移量 (Delta)
			let deltaX = x - baseGamma;
			let deltaY = y - baseBeta;

			// 3. 合併你的公式：
			// 原本公式 (x + 45) / 90 是把 -45~45 度映射到 0~1
			// 現在改為以基準點為中心，偏移 45 度為邊界
			orient.x = (deltaX + 45) / 90;
			orient.y = (deltaY + 45) / 90;

			// 4. 加上邊界限制 (Clamp)，防止數值超過 0~1 範圍
			orient.x = Math.max(-1, Math.min(1, orient.x));
			orient.y = Math.max(-1, Math.min(1, orient.y));
		}

		// 2. 初始化中樞
		const audioMap = new AudioMap(params);

		// 3. 生成 UI (此時 ID 自動與 config 掛鉤)
		audioMap.buildUI('ui-layer', [
			{ id: 'ui-intensity', key: 'intensity', label: 'Distortion', min: 0, max: 2, step: 0.02, range: [61, 100] },
			{ id: 'ui-freq', key: 'frequency', label: 'Complexity', min: 0.1, max: 10, step: 0.1, range: [0, 40] },
			{ id: 'ui-speed', key: 'speed', label: 'Evolution', min: 0, max: 0.0025, step: 0.0001, range: [41, 60] }
		]);
	</script>

	<div id="container"></div>

    <script type="importmap">
        { "imports": { "three": "https://esm.sh/three@0.160.0" } }
    </script>

    <script type="module">
		import * as THREE from 'three';

		// --- 全域變數 ---
		let renderer, scene, camera, material;
		let gyroX = 0, gyroY = 0; // 儲存陀螺儀數值
		let darkGlowMode = false;

		const _VS = `void main() { gl_Position = vec4(position, 1.0); }`;
		const _FS = `
			precision highp float;
			uniform vec2 u_res;
			uniform float u_time;
			uniform float u_volume;  // 麥克風：0.0 ~ 1.0
			uniform vec2 u_orient;   // 陀螺儀：x, y 0.0 ~ 1.0
			uniform float u_intensity;
			uniform float u_complexity;
			uniform float u_speed;
			uniform float u_darkGlow;

			float noise(vec2 p) {
				return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
			}

			vec4 drawWall(vec2 coords, float depth, float vol) {
				float d = abs(coords.y - 0.5) * 2.0;
				float sVal = 0.01; 
				float f = 1.0 - (d * sVal);
				float tx = (coords.x - 0.5) / f + 0.5;

				float aa = 0.002 + depth * 0.003;
				
				// 用 u_complexity 影響雜訊的細膩度
				float n = noise(coords * u_complexity + u_time * u_speed);
				float brightness = pow(1.0 - d, 0.1) + u_complexity * 0.1 - u_intensity * 0.3;
				float sideLight = 0.3 - 0.04 * depth;
				
				// 1. 基礎色調（深色）
				vec3 col = vec3(0.1, 0.2, 0.3); 

				// 2. 讓 rim (邊緣光) 成為主角
				float rim = pow(d, 8.0 - u_intensity * 2.0); 
				col += vec3(0.1, 0.2, 0.3) * rim * (1.0 + vol * 3.0); 

				// 3. 亮度與側光 (sideLight) 疊加
				vec3 col2 = vec3(0.1, 0.2, 0.3) * (0.5 / (d * 5.0 + 0.1));
				col += col2;
				col *= brightness * sideLight;
				
				// 聲音越大，磨砂噪點越強烈
				col -= noise(coords + depth + u_time * 0.05) * (0.03 + vol * 0.1);

				// 2. 洞口大小受音量影響 (聲音大，洞口擴張)
				float holeExpansion = vol * (0.01 + u_intensity * 0.07);
				float mask = smoothstep(0.0, aa, tx) * smoothstep(1.0, 1.0 - aa, tx);
				float inHole = smoothstep(0.02 - holeExpansion - aa, 0.02 - holeExpansion + aa, tx) 
							 * smoothstep(0.98 + holeExpansion + aa, 0.98 + holeExpansion - aa, tx) 
							 * smoothstep(0.03 - holeExpansion - aa, 0.03 - holeExpansion + aa, d) 
							 * smoothstep(0.97 + holeExpansion + aa, 0.97 + holeExpansion - aa, d);
				
				float vMaskY = smoothstep(1.0, 0.8 - aa, d);
				col *= mask * vMaskY;
				
				return vec4(col, inHole);
			}

			void main() {
				vec2 uv = gl_FragCoord.xy / u_res.xy;
				
				// 將陀螺儀數據轉換為 -1.0 到 1.0 的視角偏移
				vec2 lookDir = (u_orient - 0.5) * 2.0; 

				vec2 currentUV = uv;
				vec3 finalCol = vec3(0.0);
				float hitDeepest = 0.0;

				for (int i = 0; i < 20; i++) {
					float fi = float(i);

					// --- 核心改動：模擬投影視角 ---
					// 隨著深度 fi 增加，uv 座標被 lookDir 往相反方向推動
					// 這裡 0.05 是透視強度，數值越大，轉頭感越強
					vec2 perspectiveShift = lookDir * fi * 0.05;
					vec2 layerUV = currentUV + perspectiveShift;

					// 模擬視角傾斜導致的縮放不均勻 (Keystone Effect)
					// 當你往右看 (lookDir.x > 0)，右側內容應該被「拉近」
					layerUV = (layerUV - 0.5) * (1.0 + dot(layerUV - 0.5, lookDir) * 0.2) + 0.5;

					vec4 layer = drawWall(layerUV, fi, u_volume);

					if (layer.a < 0.5) {
						finalCol = layer.rgb;
						break;
					}
					
					// 座標旋轉與重映射邏輯 (保持不變)
					float d = abs(layerUV.y - 0.5) * 2.0;
					float tx = (layerUV.x - 0.5) / (1.0 - d * 0.02) + 0.5;
					float nextX = (tx - 0.02) / 0.96;
					float nextD = (d - 0.03) / 0.92;
					float nextY = (layerUV.y > 0.5) ? (nextD * 0.5 + 0.5) : (0.5 - nextD * 0.5);

					float dynamicSpeed = (u_speed * 0.5 + pow(u_speed, 3.0) * 0.5) * 5.0;
					float currentRotation = u_time * (0.2 + dynamicSpeed);
					float angle = 1.57 + sin(currentRotation + fi * 0.1) * 0.1;
					float s = sin(angle); float c = cos(angle);
					vec2 centered = vec2(nextX, nextY) - 0.5;
					currentUV.x = (centered.x * c - centered.y * s) + 0.5;
					currentUV.y = (centered.x * s + centered.y * c) + 0.5;
					currentUV = (currentUV - 0.5) * 1.001 + 0.5; 

					finalCol = layer.rgb;
					hitDeepest = 1.0;
				}

				if (hitDeepest > 0.5) {
					float distToCenter = length(currentUV - 0.5);
					// 深淵核心：受音量強烈驅動
					float glow = exp(-distToCenter * (4.0 - u_volume * 2.0)); 
					vec3 coreColor = vec3(0.3, 0.6, 1.0) * (u_volume * 5.0 + 0.5);
					finalCol += coreColor * glow;
				}
				
				if (u_darkGlow > 0.5) {
					// 1. 提取亮度（轉為黑白）
					float luminance = dot(finalCol, vec3(0.2126, 0.7152, 0.0722));
					
					// 2. 翻轉亮度：原本亮的地方（能量高）變成黑，暗的地方變成白
					float darkGlow = 1.0 - luminance;
					
					// 3. 增加對比度：讓黑白更分明，產生一種「蝕刻」在空間中的感覺
					darkGlow = pow(darkGlow, 2.0); 
					
					finalCol = vec3(darkGlow);
				}

				gl_FragColor = vec4(finalCol, 1.0);
			}
		`;
		
		// Slider 監聽
		const overlay = document.getElementById('overlay');
		overlay.addEventListener('click', () => audioMap.initAudio('./輪迴(找到我)(v5).mp3'+"?v=" + Date.now()));
		const link = document.getElementById('link');
		link.addEventListener('click', function() {
			window.location.assign("index.html");
		});

		// 1. 同時監聽 click 和 touchend
		['click', 'touchend'].forEach(eventType => {
			window.addEventListener(eventType, (e) => {
				const overlay = document.getElementById('overlay');
				
				// --- 攔截條件 ---
				// 如果 Overlay 還在，不執行切換
				if (overlay && overlay.style.display !== 'none') return;
				// 如果點到 UI 控制板（或是 input），不執行切換
				if (e.target.closest('#ui-layer') || e.target.tagName === 'INPUT') return;
				// 如果點到的是 Overlay 本身（雖然已經隱藏，但作為保險），不執行切換
				if (e.target.id === 'overlay') return;
				if (e.target.closest('#link')) return;

				// --- 執行切換 ---
				toggleDarkGlow();

				// 避免在某些瀏覽器上 click 和 touchend 重複觸發
				if (eventType === 'touchend') {
					// 如果點擊有效，防止後續的 click 事件產生
					// e.preventDefault(); // 注意：若有其他連結需要點擊，可視情況註解此行
				}
			}, { passive: true });
		});
		
		function toggleDarkGlow() {
			darkGlowMode = !darkGlowMode;
			// 將布林值轉為 0.0 或 1.0 傳給 Shader
			material.uniforms.u_darkGlow.value = darkGlowMode ? 1.0 : 0.0;
		}
		
		// 2. 初始化 Three.js 環境
		function init() {
			scene = new THREE.Scene();
			camera = new THREE.Camera(); // 正交相機，適合全螢幕 Shader
			
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.getElementById('container').appendChild(renderer.domElement);

			// 關鍵：在 Three.js 中定義 Uniforms
			material = new THREE.ShaderMaterial({
				uniforms: {
					u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
					u_time: { value: 0.0 },
					u_volume: { value: 0.0 },
					u_orient: { value: new THREE.Vector2(0.5, 0.5) },
					// --- 加入 UI 參數 ---
					u_intensity: { value: params.intensity },
					u_complexity: { value: params.frequency },
					u_speed: { value: params.speed },
					u_darkGlow: { value: 0.0 }
				},
				vertexShader: _VS,
				fragmentShader: _FS
			});

			const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
			scene.add(mesh);
			
			animate();
		}
		
		// 3. Three.js 的渲染循環 (取代你原本手寫的 render)
		function animate(time) {
			requestAnimationFrame(animate);

			// 更新時間
			material.uniforms.u_time.value = time * 0.001;
			try{
				// 更新音量
				if (audioMap && audioMap.isReady && audioMap.analyser && audioMap.dataArray) {
					console.log("1");
					audioMap.analyser.getByteFrequencyData(audioMap.dataArray);
					console.log("2");
					let sum = 0;
					for (let i = 0; i < audioMap.dataArray.length; i++) sum += audioMap.dataArray[i];
					material.uniforms.u_volume.value = sum / audioMap.dataArray.length / 255.0;
					
					audioMap.updateAudioReaction(audioMap.dataArray, null);
				}
			}
			catch{
				console.log("3");
			}
			

			// 更新陀螺儀
			material.uniforms.u_orient.value.set(orient.x, orient.y);
			material.uniforms.u_intensity.value = params.intensity;
			material.uniforms.u_complexity.value = params.frequency;
			material.uniforms.u_speed.value = params.speed;

			renderer.render(scene, camera);
		}

		// 啟動
		init();

		window.onresize = () => {
			renderer.setSize(window.innerWidth, window.innerHeight);
			material.uniforms.u_res.value.set(window.innerWidth, window.innerHeight);
		};
    </script>
</body>
</html>






